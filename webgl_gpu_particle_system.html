<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js - gpu particle system</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		a {
			color: #0078ff;
		}

		.dg {
			right: auto!important;
			left: 20px!important;
		}
	</style>
</head>

<body>
	<div style="position: absolute; top: 10px; width: 100%; text-align: center; color:#eee">
		<a href="http://threejs.org" target="_blank">three.js</a> - GPU particle system plugin by <a href="http://charliehoey.com">Charlie Hoey</a>.</div>

	<script src="./js/libs/three.min.js"></script>
	<script src="./js/libs/tween.js"></script>
	<script src="js/loaders/ColladaLoader2.js"></script>
	<script src="js/loaders/OBJLoader.js"></script>
	<script src="./js/controls/TrackballControls.js"></script>
	<script src="./js/libs/stats.min.js"></script>
	<script src="./js/libs/GPUParticleSystem.js" charset="utf-8"></script>

	<script>
		var camera, tick1 = 0,tick2 = 0,
			scene, renderer, clock1 = new THREE.Clock(true),clock2 = new THREE.Clock(true),
			controls, container,
			options, spawnerOptions, particleSystem;
		var curve;
		var pos=0;
		var RAD_90  = 90/180*Math.PI;            					//90度的弧度值，后面会多次用到 定义为变量减少运算

	var teamMesh, teamMaterial;

	var missileDae;

	var missileLauncher = new THREE.Group();					//发射架组，发射架的模型有两个部分，会先添加进Group中再进行操作
	var teamFlag = new THREE.Group();                           //旗帜组  暂时没用到
	var baseMesh;                 								//发射架底部棱台
	var serviceMesh;                                            //周围
	var baseOffset = new THREE.Vector3(0,0,-60);
	var serviceOffset =  new THREE.Vector3(0,0,0);
	var logoOffset = new THREE.Vector3(0,0,330);
	var cameraOffset = new THREE.Vector3(100,100,100);
	var teamsData = [];
		var particleSystems = [];




		for(var i=0;i<50;i++){
			var obj = {
				particleSystem : new THREE.GPUParticleSystem({
										maxParticles: 2500
									}),
				options : {
								position: new THREE.Vector3(),
								positionRandomness: .3,
								velocity: new THREE.Vector3(),
								velocityRandomness: .5,
								color: 0xaa88ff,
								colorRandomness: 0,
								turbulence: .5,
								lifetime: 1,
								size: 5,
								sizeRandomness: 1,
								pos: 0
							},
				clock : new THREE.Clock(true),
				tick : 0,
				available : true
			};

			particleSystems.push(obj);
		}
	


		var clock3 = new THREE.Clock(true);

		init();
		animate();

		function test(curve) {
			for(var i=0;i<particleSystems.length;i++){
				if(particleSystems[i].available){
					var system = particleSystems[i];
					console.log(system);
					system.available = false;
					scene.add(system.particleSystem);
					new TWEEN.Tween(system.options)
					.to( {pos:1}, 5000 )
					.onUpdate(function(){
						var delta = system.clock.getDelta() * spawnerOptions.timeScale;

						system.tick += delta;

						if (system.tick < 0) tick1 = 0;

						if (delta > 0) {
							system.options.position.copy(curve.getPointAt(system.options.pos));
							for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
								system.particleSystem.spawnParticle(system.options);
							}
						}
						system.particleSystem.update(system.tick);

					})
					.onComplete(function(){
						scene.remove(system.particleSystem);
						system.tick = 0;
						system.options.pos = 0;
						system.available = true;
					})
					.start();
					break;
				}
			}
		}

		function makeSkybox( urls, size ) {

			var skyboxCubemap = new THREE.CubeTextureLoader().load( urls );
			skyboxCubemap.format = THREE.RGBFormat;
			var skyboxShader = THREE.ShaderLib['cube'];
			skyboxShader.uniforms['tCube'].value = skyboxCubemap;
			return new THREE.Mesh(
				new THREE.BoxGeometry( size, size, size ),
				new THREE.ShaderMaterial({
					fragmentShader : skyboxShader.fragmentShader, vertexShader : skyboxShader.vertexShader,
					uniforms : skyboxShader.uniforms, depthWrite : false, side : THREE.BackSide
				})
			);

		}


		function pstest(){

			curve = new THREE.SplineCurve3([
			    new THREE.Vector3(0, 0, 0),
			    new THREE.Vector3(1000, 0 , 800), 
			    new THREE.Vector3(2000 , 0, 800),
			    new THREE.Vector3(3000, 0, 0)
			]);

			test(curve);
			var curve2 = new THREE.SplineCurve3([
								    new THREE.Vector3(200, 0, 0),
								    new THREE.Vector3(1000, 0 , 800), 
								    new THREE.Vector3(2000 , 0, 800),
								    new THREE.Vector3(5000, 0, 0)
								]);

			test(curve2);
		}


		function init() {


			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100000 );
		camera.position.set( 0, -5600, 4000 );
		// camera.rotation.x = RAD_90;
		camera.lookAt( new THREE.Vector3() );

			scene = new THREE.Scene();

			// The GPU Particle system extends THREE.Object3D, and so you can use it
			// as you would any other scene graph component.	Particle positions will be
			// relative to the position of the particle system, but you will probably only need one
			// system for your whole scene



			// options passed during each spawned

			spawnerOptions = {
				spawnRate: 1000,
				horizontalSpeed: 1.5,
				verticalSpeed: 1.33,
				timeScale: 1
			}



			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);


			stats = new Stats();
			stats.domElement.id = 'fps';
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.left = '1000px';
			container.appendChild( stats.domElement );

			// setup controls
			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.rotateSpeed = 5.0;
			controls.zoomSpeed = 2.2;
			controls.panSpeed = 1;
			controls.dynamicDampingFactor = 0.3;

			window.addEventListener('resize', onWindowResize, false);

		var r = "img/skybox1/";
		var urls = [ r + "px.jpg", r + "nx.jpg",
					 r + "py.jpg", r + "ny.jpg",
					 r + "pz.jpg", r + "nz.jpg" ];			 
		scene.add( makeSkybox( urls, 100000 ) );
		
		// setTimeout("pstest()",2000);

		var ambientLight = new THREE.AmbientLight( 0x606060 );
		scene.add( ambientLight );

		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 0, -0.75, -0.5 ).normalize();
		scene.add( directionalLight );




		var loader = new THREE.ColladaLoader();

		var onProgress = function ( xhr ) {
			if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round(percentComplete, 2) + '% downloaded' );
			}
		};

		var onError = function ( xhr ) {
		};



		loader.load( './models/missile.dae', function ( collada ) {
			missileDae = collada.scene;
			missileDae.traverse( function ( child ) {
				if ( child instanceof THREE.SkinnedMesh ) {
						var animation = new THREE.Animation( child, child.geometry.animation );
						animation.play();
					}
			});
			missileDae.scale.set(10,10,10);
			missileDae.rotation.x = 0;
			// setTimeout("scene.add(missileDae)",1000);
			scene.add(missileDae);
			console.log(missileDae);
			// console.log(particleSystems[0]);

		}, onProgress, onError);


		}


		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			render();

		}

		function render() {

			renderer.render(scene, camera);
			stats.update();
			TWEEN.update();

		}
	</script>
</body>

</html>
