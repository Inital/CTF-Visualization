<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js - gpu particle system</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		a {
			color: #0078ff;
		}

		.dg {
			right: auto!important;
			left: 20px!important;
		}
	</style>
</head>

<body>
	<div style="position: absolute; top: 10px; width: 100%; text-align: center; color:#eee">
		<a href="http://threejs.org" target="_blank">three.js</a> - GPU particle system plugin by <a href="http://charliehoey.com">Charlie Hoey</a>.</div>

	<script src="./js/libs/three.min.js"></script>
	<script src="./js/libs/tween.js"></script>
	<script src="./js/controls/TrackballControls.js"></script>
	<script src="./js/libs/stats.min.js"></script>
	<script src="./js/libs/GPUParticleSystem.js" charset="utf-8"></script>

	<script>
		var camera, tick = 0,
			scene, renderer, clock = new THREE.Clock(true),
			controls, container,
			options, spawnerOptions, particleSystem;
		var curve;
		var pos=0;

		init();
		animate();

		function makeSkybox( urls, size ) {

			var skyboxCubemap = new THREE.CubeTextureLoader().load( urls );
			skyboxCubemap.format = THREE.RGBFormat;
			var skyboxShader = THREE.ShaderLib['cube'];
			skyboxShader.uniforms['tCube'].value = skyboxCubemap;
			return new THREE.Mesh(
				new THREE.BoxGeometry( size, size, size ),
				new THREE.ShaderMaterial({
					fragmentShader : skyboxShader.fragmentShader, vertexShader : skyboxShader.vertexShader,
					uniforms : skyboxShader.uniforms, depthWrite : false, side : THREE.BackSide
				})
			);

		}


		function init() {


			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
			// camera.position.set( 0, -280, 200 );
			camera.position.set( 0, -2800, 2000 );
		// camera.rotation.x = RAD_90;
		camera.lookAt( new THREE.Vector3() );

			scene = new THREE.Scene();

			// The GPU Particle system extends THREE.Object3D, and so you can use it
			// as you would any other scene graph component.	Particle positions will be
			// relative to the position of the particle system, but you will probably only need one
			// system for your whole scene
			particleSystem = new THREE.GPUParticleSystem({
				maxParticles: 25000,
				containerCount: 25
			});
			scene.add(Â particleSystem);


			// options passed during each spawned
			options = {
				position: new THREE.Vector3(),
				positionRandomness: .3,
				velocity: new THREE.Vector3(),
				velocityRandomness: .5,
				color: 0xaa88ff,
				colorRandomness: 0,
				turbulence: .5,
				lifetime: 1,
				size: 5,
				sizeRandomness: 1
			};
			spawnerOptions = {
				spawnRate: 10000,
				horizontalSpeed: 1.5,
				verticalSpeed: 1.33,
				timeScale: 1
			}


			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);


			stats = new Stats();
			stats.domElement.id = 'fps';
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.left = '1000px';
			container.appendChild( stats.domElement );

			// setup controls
			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.rotateSpeed = 5.0;
			controls.zoomSpeed = 2.2;
			controls.panSpeed = 1;
			controls.dynamicDampingFactor = 0.3;

			window.addEventListener('resize', onWindowResize, false);


			new TWEEN.Tween( particleSystem)
			.to( {}, 100000 )
			.onUpdate(function(){

				var delta = clock.getDelta() * spawnerOptions.timeScale;

			tick += delta;

			if (tick < 0) tick = 0;

			if (delta > 0) {
				options.position.copy(curve.getPointAt(pos));
				// options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed) * 20;
				// options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed) * 10;
				// options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;


				// options.position.x += 0.1;

				for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
					// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
					// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
					particleSystem.spawnParticle(options);
				}
			}
			console.log(delta);

			particleSystem.update(tick);

			})
			.start();
			new TWEEN.Tween( particleSystem)
			.to( {}, 100000 )
			.onUpdate(function(){

				var delta = clock.getDelta() * spawnerOptions.timeScale;

				tick += delta;

				if (tick < 0) tick = 0;

				if (delta > 0) {
					options.position.copy(curve.getPointAt(pos)).add(new THREE.Vector3(10000,100,100));
					// options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed) * 20;
					// options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed) * 10;
					// options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;


					// options.position.x += 0.1;

					for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
						// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
						// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
						particleSystem.spawnParticle(options);
					}
				}
				console.log(delta);

				particleSystem.update(tick);

			})
			.start();

						new TWEEN.Tween( particleSystem)
			.to( {}, 100000 )
			.onUpdate(function(){

				var delta = clock.getDelta() * spawnerOptions.timeScale;

				tick += delta;

				if (tick < 0) tick = 0;

				if (delta > 0) {
					options.position.copy(curve.getPointAt(pos)).add(new THREE.Vector3(1000,100,100));
					// options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed) * 20;
					// options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed) * 10;
					// options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;


					// options.position.x += 0.1;

					for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
						// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
						// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
						particleSystem.spawnParticle(options);
					}
				}
				console.log(delta);

				particleSystem.update(tick);

			})
			.start();
									new TWEEN.Tween( particleSystem)
			.to( {}, 100000 )
			.onUpdate(function(){

				var delta = clock.getDelta() * spawnerOptions.timeScale;

				tick += delta;

				if (tick < 0) tick = 0;

				if (delta > 0) {
					options.position.copy(curve.getPointAt(pos)).add(new THREE.Vector3(1000,10000,100));
					// options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed) * 20;
					// options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed) * 10;
					// options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;


					// options.position.x += 0.1;

					for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
						// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
						// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
						particleSystem.spawnParticle(options);
					}
				}
				console.log(delta);

				particleSystem.update(tick);

			})
			.start();
		var r = "img/skybox1/";
		var urls = [ r + "px.jpg", r + "nx.jpg",
					 r + "py.jpg", r + "ny.jpg",
					 r + "pz.jpg", r + "nz.jpg" ];


		// var r = "img/skybox/";
		// var urls = [ r + "px.jpg", r + "nx.jpg",
		// 			 r + "nz.jpg", r + "pz.jpg",
		// 			 r + "py.jpg", r + "ny.jpg" ];

		scene.add( makeSkybox( urls, 50000 ) );

		curve = new THREE.SplineCurve3([
							    new THREE.Vector3(0, 0, 0),
							    new THREE.Vector3(1000, 0 , 800), 
							    new THREE.Vector3(2000 , 0, 800),
							    new THREE.Vector3(3000, 0, 0)
							]);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {
			pos+=0.008;
			if(pos>1)
				pos=0;
			requestAnimationFrame(animate);

			controls.update();

			// var delta = clock.getDelta() * spawnerOptions.timeScale;

			// tick += delta;

			// if (tick < 0) tick = 0;

			// if (delta > 0) {
			// 	options.position.copy(curve.getPointAt(pos));
			// 	// options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed) * 20;
			// 	// options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed) * 10;
			// 	// options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;


			// 	// options.position.x += 0.1;

			// 	for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
			// 		// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
			// 		// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
			// 		particleSystem.spawnParticle(options);
			// 	}
			// }
			// console.log(delta);

			// particleSystem.update(tick);
			render();

		}

		function render() {

			renderer.render(scene, camera);
			stats.update();
			TWEEN.update();

		}
	</script>
</body>

</html>
